#include<iostream>
#include<windows.h>
#include<conio.h>
#include<stdlib.h>
#include<time.h>

using namespace std;

//funcion para mover caracteres por medio dle teclado
void gotoxy(int x, int y){
HANDLE hcon = GetStdHandle(STD_OUTPUT_HANDLE);
 COORD dwPos;
 dwPos.X = x;
 dwPos.Y = y;
 SetConsoleCursorPosition(hcon, dwPos);
}
// arreglo para posicionar los barcos
//dibuja el tablero
char ma[22][22] =   {{' ',' ','A',' ','B',' ','C',' ','D',' ','E',' ','F',' ','G',' ','H',' ','I',' ','J',' '},
       {' ',' ','_','_','_','_','_','_','_','_','_','_','_','_','_','_','_','_','_','_','_',' '},
       {'0','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|'},
       {' ','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|'},
       {'1','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|'},
       {' ','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|'},
       {'2','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|'},
       {' ','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|'},
       {'3','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|'},
       {' ','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|'},
       {'4','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|'},
       {' ','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|'},
       {'5','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|'},
       {' ','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|'},
       {'6','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|'},
       {' ','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|'},
       {'7','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|'},
       {' ','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|'},
       {'8','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|'},
       {' ','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|','-','|'},
       {'9','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|',' ','|'},
       {' ',' ','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-',' '},};

struct coord
{
	int x,y;
};
//la estructura perenece a la coordenada original quien se encargara de moverse
struct pieza
{
	coord ori;
	coord peri[3];
	char D;
	char d='*';
	coord posicion(int n);
};


coord pieza::posicion(int n)
{
	coord ret={ori.x, ori.y};
	if(n!=0)
	{
		ret.x+=peri[n-1].x;
		ret.y+=peri[n-1].y;
	}
	return ret;
} 	
// esta funcion es para pasar directo los datos del tama;o de los tipos de barco
//el segundp se deja en blaco la ultima posicion por que solo queremos que tome dos posiciones
//el ultimo es la fragata y no ocupa ningun espacio
coord peris[5][3]={{{2,0},{4,0},{6,0}},
					{{2,0},{4,0},{  }},
					{{2,0},{4,0},{  }},
					{{ },{ },{ }},
					{{ },{ },{ }}
};
				
char barcos[4]={'P','S','D','F'};
// es para que imprima la tabla
char ju[22][22];
CHAR en[22][22];
// para crear naves para el tablero

class jugador{
	
	public:
		void pasarmapa();
		void dibujarmapaju();
		void pintar(pieza &,int);
		void borrar(pieza &);
		void rotar(pieza &);
		coord rotar(coord &);
		void seleccionar(pieza &, int);
		void mover(pieza &,int &);
		bool colision(pieza &);
		int obtenerxy();
		void seleccionarmapa(pieza&, int);
		
};

void jugador::pasarmapa()
{
	for(int i=0;i<22;i++)
	{
		cout<<endl;
		for(int j=0;j<22;j++)
		{
			ju[i][j]=ma[i][j];
			en[i][j]=ma[i][j];
		}
	}
}
void jugador::dibujarmapaju()
{
	for(int i=0;i<22;i++)
	{
		cout<<endl;
		for(int j=0;j<22;j++)
		{
			cout<<ju[i][j];
		}
	}
}

//funcion para imprimir porta aviones, se repite 4 veces por que portaaviones sera 4 casillas
void jugador::pintar(pieza &P,int r)
{
	//ma[P.ori.x][P.ori.y]=P.D;
	//gotoxy(P.ori.x,P.ori.y);cout<<P.D;

		for(int i=0;i<4;i++)
		{
			coord c=P.posicion(i);
			if(r==1)ju[c.y][c.x]=P.d;
			else ju[c.y][c.x]=P.D;
		}
	
	
}
void jugador::borrar(pieza &P)
{
	//ma[P.ori.x][P.ori.y]=P.D;
	//gotoxy(P.ori.x,P.ori.y);cout<<P.D;
	for(int i=0;i<4;i++)
	{
		coord c=P.posicion(i);
		ju[c.y][c.x]=' ';
	}
}
coord jugador::rotar(coord &c)
{
	coord ret={c.y,c.x};
	return ret;
};

void jugador::rotar(pieza &P)
{
	for(int i=0;i<3;i++)
	{
		P.peri[i]=jugador::rotar(P.peri[i]);
		
	}
}

/////////////////////////////////////////////////
// i vale 4 dependiendo la cantidad de tipos de barcos que se tiene
void jugador::seleccionar(pieza &P, int r)
{
	P.ori.x= jugador::obtenerxy();
	P.ori.y= jugador::obtenerxy();
	P.D=barcos[r];
	for(int i=0;i<3;i++)
	{
		P.peri[i]=peris[r][i];
		
	}
}
void jugador::mover(pieza &P,int &r)
{
	if(kbhit())
	{
		pieza copia=P;
		char tecla= getch();
		if(tecla=='a')P.ori.x-=2;
		if(tecla=='d')P.ori.x+=2;
		if(tecla=='w')P.ori.y-=2;
		if(tecla=='s')P.ori.y+=2;
		if(tecla=='c')
		{
			//al presionar la letra c rotara de horizontal a vertical y biseversa
			jugador::rotar(P);
		}
		
		if(jugador::colision(P))
		{
			//si la colision regresa verdadero tendra valor P antes de hacer el movimiento
			P=copia;
		}
		jugador::borrar(copia);
		jugador::pintar(P,1);
		if(tecla=='x')
		{
			jugador::pintar(P,2);
			r++;
			jugador::seleccionarmapa(P,r);
		}
	}
}
bool jugador::colision(pieza &P)
{
	for(int i=0;i<4;i++)
	{
		coord c=P.posicion(i);
		if(c.x<2||c.x>20) return true;
		if(c.y<2||c.y>20) return true;
		if(ju[c.y][c.x]=='P'||ju[c.y][c.x]=='S'||ju[c.y][c.x]=='D'||ju[c.y][c.x]=='F') return true;
	}
	return false;
}

int jugador::obtenerxy()
{
	while(true)
	{
		int x=rand()%19 +2;
		if(x%2 ==0)return x;
	}
	
}
void jugador::seleccionarmapa(pieza&P, int r)
{
	while(true)
	{
		jugador::seleccionar(P,r);
		if(!jugador::colision(P)) break;
	}
}


class enemigo : public jugador
{
	public:
		void dibujarmapaen();
		void pintar(pieza &,int);
		void borrar(pieza &);
		void mover(pieza &,int &);
		bool colision(pieza &);
		void seleccionarmapa(pieza &, int);
		void inicializarbarcos(pieza &);
		int obtenerrot();
};

void enemigo::dibujarmapaen()
{
	for(int i=0;i<22;i++)
	{
		cout<<endl;
		for(int j=0;j<22;j++)
		{
			cout<<en[i][j];
		}
	}
}

void enemigo::pintar(pieza &P, int r)
{
		for(int i=0;i<4;i++)
		{
			coord c=P.posicion(i);
			if(r==1)en[c.y][c.x]=P.d;
			else en[c.y][c.x]=P.D;
		}
	
}
void enemigo::borrar(pieza &P)
{
	for(int i=0;i<4;i++)
	{
		coord c=P.posicion(i);
		en[c.y][c.x]=' ';
	}
}

void enemigo::mover(pieza &P,int &r)
{
	if(kbhit())
	{
		pieza copia=P;
		char tecla= getch();
		if(tecla=='a')P.ori.x-=2;
		if(tecla=='d')P.ori.x+=2;
		if(tecla=='w')P.ori.y-=2;
		if(tecla=='s')P.ori.y+=2;
		if(enemigo::colision(P))
		{
			P=copia;
		}
		enemigo::borrar(copia);
		enemigo::pintar(P,1);
	}
}
bool enemigo::colision(pieza &P)
{
	for(int i=0;i<4;i++)
	{
		coord c=P.posicion(i);
		if(c.x<2||c.x>20) return true;
		if(c.y<2||c.y>20) return true;
		if(en[c.y][c.x]=='P'||en[c.y][c.x]=='S'||en[c.y][c.x]=='D'||en[c.y][c.x]=='F') return true;
	}
	return false;
}

void enemigo::seleccionarmapa(pieza&P, int r)
{
	while(true)
	{
		enemigo::seleccionar(P,r);
		if(!enemigo::colision(P)) break;
	}
}

int enemigo::obtenerrot()
{
	int x=rand()%2;
	return x;
}
//esta funcion es para 
void enemigo::inicializarbarcos(pieza &P)
{
	for(int i=0;i<5;i++)
	{
		while(true)
		{
			enemigo::seleccionar(P,i);
			if(enemigo::obtenerrot()==0) enemigo::rotar(P);
			if(!enemigo::colision(P))
			{
				enemigo::pintar(P,2);
				break;
			}
		}
	}
}
int main ()
{
	//funcion rand para generar numero aleatorio
	srand(time(NULL));
	jugador a;
	enemigo b;
	pieza S,S1;
	int r=0;
	int t=0;
	a.pasarmapa();
	a.seleccionar(S,r);
	b.inicializarbarcos(S1);
	while(true)
	{
		gotoxy(0,25);
		a.dibujarmapaju();
		gotoxy(0,0);
		b.dibujarmapaen();
		if(t==0)
		{
			a.mover(S,r);
			if(r==4) t=1;			
		}
		if(t==1)
		{
			b.mover(S1,r);
		}
	
	}
	//2,28 corresponde a origen y lo demas a perifericos
	//pieza c={{2,28},{{2,0},{4,0},{6,0}},'P'};
	//pieza v={{2,28},{{2,0},{4,0},{6,0}},'P'};
	// se declara q1 y w1 por que se esta pasando una direccion en lugar de un valor para permitir borrar las O al cambiar de posicion
	// se cambio los valores a 2 y 3 para que coincida con la tabla impresa en ma
	//b.pintar(v);
	//b.rotar(S);
	//b.pintar(S);
	//a.pintarmapa();
	
	return 0;
	
}
